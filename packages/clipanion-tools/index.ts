import {execFile}                          from 'child_process';
import {promisify}                         from 'util';

// Generated by running `yarn gen-types`
import type {CommandSpec, Token, TokenSet} from './types';

export type * from './types';

const execFileP = promisify(execFile);

function consumeTokensWhile(args: Array<string>, tokens: Array<Token>, tokenIndex: number, predicate: (token: Token) => boolean) {
  const isTokenRightAfter = (token: Token, previousToken: Token) => {
    return previousToken.slice.end === args[previousToken.argIndex]!.length
      ? token.argIndex === previousToken.argIndex + 1 && token.slice.start === 0
      : token.argIndex === previousToken.argIndex && token.slice.start === previousToken.slice.end;
  };

  const startTokenIndex = tokenIndex;
  const startToken = tokens[tokenIndex]!;

  let endToken: Token | null = startToken;
  let endTokenIndex = tokenIndex;

  while (tokenIndex + 1 < tokens.length) {
    const nextToken = tokens[tokenIndex + 1]!;
    if (!predicate(nextToken))
      break;

    if (!isTokenRightAfter(nextToken, endToken))
      break;

    endToken = nextToken;
    endTokenIndex += 1;

    tokenIndex += 1;
  }

  const start = {
    tokenIndex: startTokenIndex,
    argIndex: startToken.argIndex,
    offset: startToken.slice.start,
  };

  const end = {
    tokenIndex: endTokenIndex,
    argIndex: endToken.argIndex,
    offset: endToken.slice.end,
  };

  return {
    start,
    end,
  };
}

export class ClipanionBinary {
  private readonly binPath: string;
  private readonly commandSpecs: Promise<Array<CommandSpec> | null>;

  constructor(binPath: string) {
    this.binPath = binPath;

    this.commandSpecs = this.query<Array<CommandSpec>>([`--clipanion-commands`]);
  }

  async commands() {
    return await this.commandSpecs ?? [];
  }

  async describeCommandLine(args: Array<string>) {
    const queryResult = await this.query<TokenSet>([`--clipanion-tokens`, ...args]);
    if (!queryResult)
      return null;

    const commandSpecs = await this.commandSpecs;
    if (!commandSpecs)
      throw new Error(`Failed to get command specs for binary '${this.binPath}'`);

    const {commandId, tokens} = queryResult;
    const commandSpec = commandSpecs[commandId]!;

    const annotations: Array<{
      type: Token[`type`];
      start: {tokenIndex: number, argIndex: number, offset: number};
      end: {tokenIndex: number, argIndex: number, offset: number};
      description: string | null;
    }> = [];

    for (let t = 0; t < tokens.length; t++) {
      const token = tokens[t]!;
      if (token.type === `syntax`)
        continue;

      const description = token.type === `keyword`
        ? commandSpec.description
        : commandSpec.components[token.componentId]!.description;

      if (description === null)
        continue;

      switch (token.type) {
        case `keyword`: {
          const {start, end} = consumeTokensWhile(args, tokens, t, token => token.type === `keyword`);
          annotations.push({
            start,
            end,
            description,
            type: `keyword`,
          });
          t = end.tokenIndex;
          break;
        }

        case `option`: {
          const {start, end} = consumeTokensWhile(args, tokens, t, token => token.type === `assign` || token.type === `value`);
          annotations.push({
            start,
            end,
            description,
            type: `option`,
          });
          t = end.tokenIndex;
          break;
        }

        default: {
          annotations.push({
            start: {tokenIndex: t, argIndex: token.argIndex, offset: token.slice.start},
            end: {tokenIndex: t, argIndex: token.argIndex, offset: token.slice.end},
            description,
            type: token.type,
          });
          break;
        }
      }
    }

    return {
      command: commandSpec.primaryPath,
      tokens,
      annotations,
    };
  }

  private async query<T>(args: Array<string>): Promise<T | null> {
    const result = await execFileP(this.binPath, args, {
      encoding: `utf-8`,
    });

    return JSON.parse(result.stdout as string) as T;
  }
}
