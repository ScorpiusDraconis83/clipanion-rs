import {execFile}                     from 'child_process';
import {promisify}                    from 'util';

// Generated by running `yarn gen-types`
import {CommandSpec, Token, TokenSet} from './types';

export * from './types';

const execFileP = promisify(execFile);

export class ClipanionBinary {
  private readonly binPath: string;
  private readonly commandSpecs: Promise<Array<CommandSpec>>;

  constructor(binPath: string) {
    this.binPath = binPath;

    this.commandSpecs = this.query<Array<CommandSpec>>([`--clipanion-commands`]);
  }

  async describeCommandLine(args: Array<string>) {
    const tokenSet = await this.query<TokenSet>([`--clipanion-tokens`, ...args]);
    const commandSpec = (await this.commandSpecs)[tokenSet.commandId]!;

    const createTags = () => ({
      type: `unknown` as `unknown` | `keyword` | `positional` | `option` | `value`,
      description: null as string | null,
    });

    const explodedArgs = args.map(arg => [...arg].map(char => ({
      char,
      tags: createTags(),
    })));

    const applyToSlice = <T extends keyof ReturnType<typeof createTags>>(token: Token, key: T, value: ReturnType<typeof createTags>[T]) => {
      for (let i = token.slice.start; i < token.slice.end; i++) {
        explodedArgs[token.argIndex]![i]!.tags[key] = value;
      }
    };

    for (const token of tokenSet.tokens) {
      switch (token.type) {
        case `keyword`:
          applyToSlice(token, `type`, `keyword`);
          applyToSlice(token, `description`, commandSpec.description);
          break;
        case `positional`:
          applyToSlice(token, `type`, `positional`);
          applyToSlice(token, `description`, commandSpec.components[token.componentId]!.description);
          break;
        case `option`:
          applyToSlice(token, `type`, `option`);
          applyToSlice(token, `description`, commandSpec.components[token.componentId]!.description);
          break;
        case `value`:
          applyToSlice(token, `type`, `value`);
          applyToSlice(token, `description`, commandSpec.components[token.componentId]!.description);
          break;
      }
    }

    const finalTokens: Array<{
      text: string;
      tags: ReturnType<typeof createTags>;
    }> = [];

    let currentStringifiedTags: string | null = null;

    const pushChar = (char: {
      char: string;
      tags: ReturnType<typeof createTags>;
    }) => {
      const stringifiedTags = JSON.stringify(char.tags);

      if (stringifiedTags !== currentStringifiedTags) {
        currentStringifiedTags = stringifiedTags;

        finalTokens.push({
          text: ``,
          tags: char.tags,
        });
      }

      finalTokens[finalTokens.length - 1]!.text += char.char;
    };

    for (const [argIndex, chars] of explodedArgs.entries()) {
      if (argIndex > 0) {
        pushChar({
          char: ` `,
          tags: createTags(),
        });
      }

      for (const char of chars) {
        pushChar(char);
      }
    }

    return finalTokens;
  }

  private async query<T>(args: Array<string>): Promise<T> {
    const result = await execFileP(this.binPath, args, {
      encoding: `utf-8`,
    });

    return JSON.parse(result.stdout as string) as T;
  }
}
