import { execFile } from 'child_process';
import { promisify } from 'util';

// Generated by running `yarn gen-types`
import type { CommandSpec, Token, TokenSet } from './types';

export type * from './types';

const execFileP = promisify(execFile);

function consumeTokensWhile(args: Array<string>, tokens: Array<Token>, tokenIndex: number, predicate: (token: Token) => boolean) {
  const isTokenRightAfter = (token: Token, previousToken: Token) => {
    return previousToken.slice.end === args[previousToken.argIndex]!.length
      ? token.argIndex === previousToken.argIndex + 1 && token.slice.start === 0
      : token.argIndex === previousToken.argIndex && token.slice.start === previousToken.slice.end;
  };

  const startTokenIndex = tokenIndex;
  const startToken = tokens[tokenIndex]!;

  let endToken: Token | null = startToken;
  let endTokenIndex = tokenIndex;

  while (tokenIndex + 1 < tokens.length) {
    const nextToken = tokens[tokenIndex + 1]!;
    if (!predicate(nextToken))
      break;

    if (!isTokenRightAfter(nextToken, endToken))
      break;

    endToken = nextToken;
    endTokenIndex += 1;

    tokenIndex += 1;
  }

  const start = {
    tokenIndex: startTokenIndex,
    argIndex: startToken.argIndex,
    offset: startToken.slice.start,
  };

  const end = {
    tokenIndex: endTokenIndex,
    argIndex: endToken.argIndex,
    offset: endToken.slice.end,
  };

  return {
    start,
    end,
  };
}

export class ClipanionBinary {
  private readonly binPath: string;
  private readonly commandSpecs: Promise<Array<CommandSpec> | null>;

  constructor(binPath: string) {
    this.binPath = binPath;

    this.commandSpecs = this.query<Array<CommandSpec>>([`--clipanion-commands`]);
  }

  async commands() {
    return await this.commandSpecs ?? [];
  }

  async describeCommandLine(args: Array<string>) {
    const queryResult = await this.query<TokenSet>([`--clipanion-tokens`, ...args]);
    if (!queryResult)
      return null;

    const commandSpecs = await this.commandSpecs;
    if (!commandSpecs)
      throw new Error(`Failed to get command specs for binary '${this.binPath}'`);

    const { commandId, tokens } = queryResult;
    const commandSpec = commandSpecs[commandId]!;

    const annotations: Array<{
      type: Token[`type`];
      start: { tokenIndex: number, argIndex: number, offset: number };
      end: { tokenIndex: number, argIndex: number, offset: number };
      description: string | null;
    }> = [];

    for (let t = 0; t < tokens.length; t++) {
      const token = tokens[t]!;
      if (token.type === `syntax`)
        continue;

      let description: string | null = commandSpec.documentation?.description ?? null;

      if (`componentId` in token) {
        const component = commandSpec.components[token.componentId]!;
        if (`documentation` in component) {
          description = component.documentation?.description ?? null;
        }
      }

      switch (token.type) {
        case `keyword`: {
          const { start, end } = consumeTokensWhile(args, tokens, t, token => token.type === `keyword`);
          annotations.push({
            start,
            end,
            description,
            type: `keyword`,
          });
          t = end.tokenIndex;
          break;
        }

        case `option`: {
          const { start, end } = consumeTokensWhile(args, tokens, t, token => token.type === `assign`);
          annotations.push({
            start,
            end,
            description,
            type: `option`,
          });
          t = end.tokenIndex;
          break;
        }

        default: {
          annotations.push({
            start: { tokenIndex: t, argIndex: token.argIndex, offset: token.slice.start },
            end: { tokenIndex: t, argIndex: token.argIndex, offset: token.slice.end },
            description,
            type: token.type,
          });
          break;
        }
      }
    }

    return {
      command: commandSpec.primaryPath,
      tokens,
      annotations,
    };
  }

  private async query<T>(args: Array<string>): Promise<T | null> {
    const result = await execFileP(this.binPath, args, {
      encoding: `utf-8`,
    });

    return JSON.parse(result.stdout as string) as T;
  }
}

export async function parseCli<T extends { binary: ClipanionBinary }>(line: string, clis: Record<string, T>) {
  if (line.startsWith(`#`) || line.length === 0)
    return null;

  const words = [...line.matchAll(/"[^"]+"|'[^']+'|[^\s]+/g)]
    .map(match => ({ index: match.index, text: match[0]! }));

  if (words.length === 0)
    return null;

  const binaryWord = words.shift()!;
  if (!Object.hasOwn(clis, binaryWord.text))
    return null;

  const cli = clis[binaryWord.text]!;
  const args = words.map(word => word.text);

  const query = await cli.binary.describeCommandLine(args);
  if (!query)
    return null;

  for (const token of query.tokens)
    token.argIndex += 1;

  for (const annotation of query.annotations) {
    annotation.start.tokenIndex += 1;
    annotation.end.tokenIndex += 1;

    annotation.start.argIndex += 1;
    annotation.end.argIndex += 1;
  }

  words.unshift(binaryWord);

  query.tokens.unshift({
    type: `binary`,
    argIndex: 0,
    slice: { start: 0, end: binaryWord.text.length },
  });

  query.annotations.unshift({
    start: { tokenIndex: 0, argIndex: 0, offset: 0 },
    end: { tokenIndex: 0, argIndex: 0, offset: binaryWord.text.length },
    type: `binary`,
    description: null,
  });

  return { cli, words, query };
}
